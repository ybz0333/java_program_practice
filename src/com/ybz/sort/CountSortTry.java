package com.ybz.sort;
/*
 * 时间复杂度为O(n)的排序算法
不是基于比较的排序算法
思想来自于桶排序
比较常规的有计数排序、基数排序

计数排序：
身高
张三175、李四185、王五168
设身高范围为100~300，建立从100到300的桶，将三个员工归入桶中，再从100号桶开始依次倒出员工，倒出的顺序就是按身高排序的顺序
王五168、张三175、李四185

基数排序：
假设被排序的数是十进制的
023 014 101 072 084 011
准备0~9共10个桶
根据个位数的大小将所有数入桶
	011			084
	101	072	023	014
0	1	2	3	4	5	6	7	8	9
再从0号到9号依次倒出
101 011 072 023 014 084
再根据十位数的大小从左到右将所有数入桶，再从0号到9号依次倒出
再根据百位数的大小从左到右将所有数入桶，再从0号到9号依次倒出，即可完成排序
基数排序的入桶出桶用队列来实现？（每个桶先进先出）
 */

/*
 * 关于java中栈内存和堆内存
 * 栈内存: 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配的
 * 堆内存： 用于存放由new创建的对象和数组（在没有引用变量指向它们时需要垃圾回收器回收）
 * 
 * 栈内存中的变量指向堆内存中的变量
 * 
 * 1.内存分配策略
 * 
 * 按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的.

	静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的
	存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存
	分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和
	释放.
 * 
 * 2.堆和栈的比较
 * 
 * 从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的: 

	在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。
	实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会
	自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容
	销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模
	块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确
	定的,不变的,而这个"大小多少"是在编译时确定的,不是在运行时.
	
	堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都
	要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道
	存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内
	存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个
	对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种
	灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的
	原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~).
 * 
 */

/*
 * 数组的初始化：
 * 1.动态初始化：数组定义与为数组分配空间和赋值的操作分开进行；
 * 2.静态初始化：在定义数字的同时就为数组元素分配空间并赋值；
 * 3.默认初始化：数组是引用类型，它的元素相当于类的成员变量，因此数组分配空间后，每个元素也被按照成员变量的规则被隐式初始化。
 * 对于3，数组中的元素会默认初始化为0吗？还是会有不确定值？
 * 静态初始化：int[] a = {1,2,3};
 * 动态初始化：int[] a; a[0]=1; a[1]=1; a[2]=1;
 * 默认初始化：int[] a = new int[3];
 */
public class CountSortTry {
	
	public static void countSort(int[] arr) {
		int min = arr[0];
		int max = arr[0];
		for(int i=1; i<arr.length; i++) {
			//可以直接这样写
			//min = Math.min(min, arr[i]);
			//max = Math.max(max, arr[i]);
			if(arr[i] < min) {
				min = arr[i];
			}
			if(arr[i] > max) {
				max = arr[i];
			}
		}
		
		int[] help = new int[max - min + 1];
		for(int i=0; i<arr.length; i++) {
			help[arr[i] - min]++;
		}
		
		int index = 0;
		for(int i=0; i<help.length; i++) {
			while(help[i]-- > 0) {
				arr[index++] = i + min;
			}
		}
	}
	
	public static void printArray(int[] arr) {
		for(int x : arr) {
			System.out.print(x + " ");
		}
		System.out.println();
	}
	
	public static int[] generateArray(int length, int range) {
		int[] arr = new int[length];
		for(int i=0; i<length; i++) {
			arr[i] = (int)(Math.random() * range);
		}
		return arr;
	}
	
	public static void main(String[] args) {
		int[] arr = generateArray(10, 10);
		printArray(arr);
		countSort(arr);
		printArray(arr);
	}
}
